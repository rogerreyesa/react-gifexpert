{"version":3,"sources":["components/AddCategory.js","components/helpers/getGifs.js","components/GridItem.js","components/GifGrid.js","components/hooks/useFetchGifs.js","GifExpertAPP.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","gifsResponse","json","data","gifs","map","gif","id","title","images","downsized_medium","GridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","console","log","useFetchGifs","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"mMAGaA,EAAc,SAAC,GAAyB,IAAtBC,EAAqB,EAArBA,cAAqB,EAIZC,mBAAS,IAJG,mBAIzCC,EAJyC,KAI7BC,EAJ6B,KA2BhD,OAKI,aAJA,CAIA,QAAMC,SAnBW,SAACC,GAGlBA,EAAEC,iBACEJ,EAAWK,OAAOC,OAAS,IAE3BR,GAAe,SAAAS,GAAI,OAAKP,GAAL,mBAAoBO,OACvCN,EAAc,MAYlB,SAEI,uBACIO,KAAK,OACLC,MAAST,EACTU,SA7Bc,SAACP,GACvBF,EAAcE,EAAEQ,OAAOF,a,+BCVlBG,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAEbC,EAFa,0FAE6EC,UAAWH,GAFxF,qBAGQI,MAAOF,GAHf,cAGbG,EAHa,gBAIIA,EAAaC,OAJjB,uBAIXC,EAJW,EAIXA,KAEFC,EAAOD,EAAKE,KAAK,SAAAC,GAAO,IAAD,EACzB,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAVvB,kBAiBZM,GAjBY,4CAAH,sDCAPO,EAAW,SAAC,GAAuB,EAApBJ,GAAqB,IAAjBC,EAAgB,EAAhBA,MAAOV,EAAS,EAATA,IAEnC,OACI,sBAAKc,UAAU,yCAAf,UAEI,qBAAKC,IAAOf,EAAMgB,IAAQN,IAC1B,4BAAKA,QCHJO,EAAU,SAAC,GAAmB,IAAhBnB,EAAe,EAAfA,SAAe,ECFd,SAAEA,GAAe,IAAD,EAEdd,mBAAS,CAC/BqB,KAAM,GACNa,SAAS,IAJ2B,mBAEjCC,EAFiC,KAE1BC,EAF0B,KAmBxC,OAZAC,qBAAU,WACNxB,EAASC,GAAWwB,MAChB,SAAAhB,GACSiB,QAAQC,IAAIlB,GACbc,EAAS,CACLf,KAAMC,EACNY,SAAS,SAI1B,CAACpB,IAEGqB,EDPwBM,CAAc3B,GAAjCa,EAV0B,EAU/BN,KAAaa,EAVkB,EAUlBA,QAKpB,OACI,qCACA,qBAAIJ,UAAU,oCAAd,cAAqDhB,EAArD,OACA,sBAAKgB,UAAU,YAAf,UAIGI,GAAW,mBAAGJ,UAAU,mCAAb,wBAkBRH,EAAOJ,KAAK,SAAAC,GAAG,OACb,cAAC,EAAD,eAEIA,GADEA,EAAIC,cEPXiB,EAnCM,WAEjB,IAFsB,EAKc1C,mBAHb,CAAE,iBAFH,mBAKf2C,EALe,KAKH5C,EALG,KActB,OAAO,qCACH,gDAEA,cAAC,EAAD,CAAaA,cAAkBA,IAC/B,uBAGA,6BAEQ4C,EAAWpB,KAAK,SAAAT,GAAQ,OAIpB,aAFA,CAEC,EAAD,CAA0BA,SAAaA,GAAvBA,Y,MC3BpC8B,IAASC,OACP,cAAC,EAAD,IACAC,SAASC,eAAe,W","file":"static/js/main.f32abe60.chunk.js","sourcesContent":["import React, {useState} from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nexport const AddCategory = ( { setCategories } ) => {\r\n\r\n    // Para saber lo que esta escrito usaremos el useState\r\n\r\n    const [inputValue, setInputValue] = useState('');\r\n\r\n    // Definir una funcion para manejar el cambio de texto en el imput\r\n    // colocarlo en el state inputValue\r\n    const handleInputChange = (e) => {\r\n        setInputValue(e.target.value);\r\n    }\r\n\r\n    // definir una funcion para cuando se presiona enter en el input\r\n    const handleSubmit = (e) => {\r\n        // prevenir el comportamiento por default del formulario usar:\r\n        // e.preventDefault()\r\n        e.preventDefault();\r\n        if (inputValue.trim().length > 2) {\r\n            // Como no llegan las categorias, usamos el callback)\r\n            setCategories( cats => [inputValue, ...cats ]);\r\n            setInputValue('');\r\n        }\r\n        // console.log('Submit Hecho');\r\n        \r\n        \r\n\r\n    }\r\n    return (\r\n        // cambiar a formulario en lugar de fragment. Agregamos al form\r\n        // el evento onSubmit para prevenir el refresh completo al momento \r\n        // del post\r\n        // <>\r\n        <form onSubmit = {handleSubmit}>\r\n            {/* <h2>Add Category</h2> */}\r\n            <input \r\n                type=\"text\"\r\n                value= { inputValue }\r\n                onChange = { handleInputChange}\r\n            />  \r\n        </form>          \r\n        // </>\r\n    )\r\n}\r\n// usar PropTypes para requerir la funcion setCategories\r\nAddCategory.propTypes = {\r\n    setCategories: PropTypes.func.isRequired\r\n}","// Se agrega getGifs como una funcion JS, al ser asincrona devolvera un promesa\r\n// la cual se puede recibir en el invocador, en eset caso GifGrid.js\r\nexport const getGifs = async( category ) => {\r\n\r\n    const url = `https://api.giphy.com/v1/gifs/search?api_key=FqP9qpmYf5MzzGCTmCkTbFwO17IWGq1r&q=${ encodeURI( category ) }&limit=5`;\r\n    const gifsResponse = await fetch( url );\r\n    const { data } = await gifsResponse.json();\r\n\r\n    const gifs = data.map( gif =>{\r\n        return {\r\n            id: gif.id,\r\n            title: gif.title,\r\n            url: gif.images?.downsized_medium.url\r\n\r\n        }\r\n    })\r\n    // console.log(gifs);\r\n    // setImagenes(gifs);\r\n    // Esta funcion al ser async, devuelve una promesa con la coleccion de los gifs obtenidos\r\n    return gifs;\r\n}","import React from 'react'\r\n\r\nexport const GridItem = ( { id, title, url}) => {\r\n        // console.log({ id, title, url});\r\n    return (\r\n        <div className=\"card animate__animated animate__bounce\">  \r\n        {/* <div className=\"card animate__animated animate__heartBeat\">                    */}\r\n            <img src= { url } alt = { title } />\r\n            <p>{ title }</p>\r\n        </div>\r\n    )\r\n}\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { useFetchGifs } from './hooks/useFetchGifs';\r\nimport { GridItem } from './GridItem';\r\n\r\nexport const GifGrid = ( { category }) => {\r\n\r\n    // const [imagenes, setImagenes] = useState([]);\r\n\r\n    // useEffect(() => {\r\n    //     getGifs( category ).then( gifs => setImagenes(gifs));\r\n    // }, [ category ]);\r\n\r\n    // console.log(imagenes)\r\n\r\n    const {data:images, loading} = useFetchGifs( category );\r\n    // console.log(loading);\r\n    // console.log(dataGifs);\r\n\r\n\r\n    return (\r\n        <>\r\n        <h3 className='animate__animated animate__fadeIn'> { category } </h3>\r\n        <div className='card-grid'>\r\n\r\n         {/* { loading ? <p>Loading...</p> : ''} */}\r\n         {/* otra mejor opcion es */}\r\n         { loading && <p className='animate__animated animate__flash'>Loading...</p>}\r\n\r\n          {/* <ol>            \r\n              {                \r\n                 imagenes.map( img => (\r\n                    <li key = {img.id}> { img.title }</li>\r\n                 )) \r\n              }\r\n          </ol> */}\r\n          {/* {\r\n            imagenes.map( img => (\r\n                <GridItem \r\n                key= {img.id}\r\n                {...img} /> // con esta instruccion se envian todo los valores del obj como props\r\n            ))\r\n          }           */}\r\n\r\n          {\r\n              images.map( gif => (\r\n                <GridItem \r\n                key= {gif.id}\r\n                {...gif} />\r\n            ))\r\n          }\r\n        </div>\r\n        </>\r\n    )\r\n}\r\n\r\nGifGrid.propTypes = {\r\n    category: PropTypes.string.isRequired\r\n}\r\n\r\n","import { useEffect, useState } from 'react'\r\nimport { getGifs } from '../helpers/getGifs'\r\n\r\nexport const useFetchGifs = ( category ) => {\r\n\r\n    const [state, setState] = useState({\r\n        data: [],\r\n        loading: true,\r\n    });\r\n\r\n    useEffect(() => {\r\n        getGifs( category ).then(\r\n            gifs => {\r\n                     console.log(gifs);\r\n                    setState({\r\n                        data: gifs,\r\n                        loading: false\r\n                    });\r\n            }\r\n        )\r\n    }, [category]);    \r\n\r\n    return state;\r\n}\r\n","\r\nimport React, {useState} from 'react';\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\nconst GifExpertApp = () =>{\r\n\r\n    const initCategories = [ 'One Puch Man'];\r\n\r\n    // para lista dinamicas y modifables desde UI se puede usar useState\r\n    const [categories, setCategories] = useState(initCategories);\r\n\r\n    // definir una funcion para el boton\r\n    // const handleAdd = () =>{\r\n    //     const siguiente = (categories.length + 1).toString();\r\n    //     // setCategories( [...categories,'NuevoValor' + siguiente ]);\r\n    //     // otra opcion es usar el callback\r\n    //     setCategories( cats => [...categories, 'NuevoValor'+ siguiente]);\r\n    // }\r\n    return <>\r\n        <h2> GifExpertApp </h2>\r\n        {/* <AddCategory /> */}\r\n        <AddCategory setCategories = { setCategories } />\r\n        <hr />\r\n        {/* <button onClick= {handleAdd}>Agregar</button> */}\r\n        {/* crear una lista para mostrar las categorias */}\r\n        <ol>\r\n            {\r\n                categories.map( category =>(\r\n                    \r\n                    // return <li key= {category}> {category} </li>\r\n                    // agregamos el componente GifGrid\r\n                    <GifGrid key = {category} category = { category } />\r\n                ))\r\n            }\r\n        </ol>\r\n    </>\r\n\r\n};\r\n\r\nexport default GifExpertApp;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport GifExpertApp from './GifExpertAPP';\nimport './index.css';\n\nReactDOM.render(\n  <GifExpertApp /> ,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n"],"sourceRoot":""}